// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: season_queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSeason = `-- name: CreateSeason :exec
INSERT INTO seasons (id, season_start, season_end, season_fund, season_status)
VALUES ($1, $2, $3, $4, 'planned')
`

type CreateSeasonParams struct {
	ID          int64
	SeasonStart pgtype.Timestamptz
	SeasonEnd   pgtype.Timestamptz
	SeasonFund  pgtype.Int4
}

func (q *Queries) CreateSeason(ctx context.Context, arg CreateSeasonParams) error {
	_, err := q.db.Exec(ctx, createSeason,
		arg.ID,
		arg.SeasonStart,
		arg.SeasonEnd,
		arg.SeasonFund,
	)
	return err
}

const endSeason = `-- name: EndSeason :exec
UPDATE seasons SET season_status = 'ended' WHERE id = $1
`

func (q *Queries) EndSeason(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, endSeason, id)
	return err
}

const getAllSeasons = `-- name: GetAllSeasons :many
SELECT id, season_start, season_end, season_fund, season_status FROM seasons
`

func (q *Queries) GetAllSeasons(ctx context.Context) ([]Season, error) {
	rows, err := q.db.Query(ctx, getAllSeasons)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Season
	for rows.Next() {
		var i Season
		if err := rows.Scan(
			&i.ID,
			&i.SeasonStart,
			&i.SeasonEnd,
			&i.SeasonFund,
			&i.SeasonStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeason = `-- name: GetSeason :one
SELECT id, season_start, season_end, season_fund, season_status FROM seasons 
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetSeason(ctx context.Context, id int64) (Season, error) {
	row := q.db.QueryRow(ctx, getSeason, id)
	var i Season
	err := row.Scan(
		&i.ID,
		&i.SeasonStart,
		&i.SeasonEnd,
		&i.SeasonFund,
		&i.SeasonStatus,
	)
	return i, err
}

const getSeasonLeaderBoard = `-- name: GetSeasonLeaderBoard :many
WITH cte AS (
    SELECT season_id, user_id, win FROM leaderboard
    WHERE season_id = $1
)
SELECT season_id, user_id, win FROM cte ORDER BY win DESC
`

type GetSeasonLeaderBoardRow struct {
	SeasonID int64
	UserID   int32
	Win      int32
}

func (q *Queries) GetSeasonLeaderBoard(ctx context.Context, seasonID int64) ([]GetSeasonLeaderBoardRow, error) {
	rows, err := q.db.Query(ctx, getSeasonLeaderBoard, seasonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSeasonLeaderBoardRow
	for rows.Next() {
		var i GetSeasonLeaderBoardRow
		if err := rows.Scan(&i.SeasonID, &i.UserID, &i.Win); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeasonsByID = `-- name: GetSeasonsByID :many
SELECT id, season_start, season_end, season_fund, season_status FROM seasons 
WHERE id IN (
    SELECT unnest($1::int[])
)
`

func (q *Queries) GetSeasonsByID(ctx context.Context, seasonIds []int32) ([]Season, error) {
	rows, err := q.db.Query(ctx, getSeasonsByID, seasonIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Season
	for rows.Next() {
		var i Season
		if err := rows.Scan(
			&i.ID,
			&i.SeasonStart,
			&i.SeasonEnd,
			&i.SeasonFund,
			&i.SeasonStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const startSeason = `-- name: StartSeason :exec
UPDATE seasons SET season_status = 'current' WHERE id = $1
`

func (q *Queries) StartSeason(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, startSeason, id)
	return err
}
